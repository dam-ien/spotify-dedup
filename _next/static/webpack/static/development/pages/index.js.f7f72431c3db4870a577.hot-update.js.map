{"version":3,"file":"static/webpack/static/development/pages/index.js.f7f72431c3db4870a577.hot-update.js","sources":["webpack:///./dedup/deduplicator.ts"],"sourcesContent":["import promisesForPages from './promiseForPages';\nimport { SpotifyTrackType, SpotifyPlaylistType } from './spotify-api';\nimport { PlaylistModel } from './types';\n\nclass BaseDeduplicator {\n  async removeDuplicates(model) {\n    throw 'Not implemented';\n  }\n\n  async getTracks() {\n    throw 'Not implemented';\n  }\n\n  static findDuplicatedTracks(tracks: Array<SpotifyTrackType>) {\n    const seenIds: { [key: string]: boolean } = {};\n    const seenNameAndArtist = {};\n    const result = tracks.reduce((duplicates, track, index) => {\n      if (track === null) return duplicates;\n      if (track.id === null) return duplicates;\n      let isDuplicate = false;\n      const seenNameAndArtistKey = `${track.name}:${track.artists[0].name}`;\n      if (track.id in seenIds) {\n        // if the two tracks have the same Spotify ID, they are duplicates\n        isDuplicate = true;\n      } else {\n        // if they have the same name, main artist, and roughly same duration\n        // we consider tem duplicates too\n        if (\n          seenNameAndArtistKey in seenNameAndArtist &&\n          Math.abs(\n            seenNameAndArtist[seenNameAndArtistKey] - track.duration_ms\n          ) < 2000\n        ) {\n          isDuplicate = true;\n        }\n      }\n      if (isDuplicate) {\n        duplicates.push({\n          index: index,\n          track: track,\n          reason: track.id in seenIds ? 'same-id' : 'same-name-artist',\n        });\n      } else {\n        seenIds[track.id] = true;\n        seenNameAndArtist[seenNameAndArtistKey] = track.duration_ms;\n      }\n      return duplicates;\n    }, []);\n    return result;\n  }\n}\n\nexport class PlaylistDeduplicator extends BaseDeduplicator {\n  static async getTracks(\n    api,\n    playlist: SpotifyPlaylistType\n  ): Promise<Array<SpotifyTrackType>> {\n    return new Promise((resolve, reject) => {\n      const tracks = [];\n      promisesForPages(\n        api,\n        api.getGeneric(playlist.tracks.href) // 'https://api.spotify.com/v1/users/11153223185/playlists/0yygtDHfwC7uITHxfrcQsF/tracks'\n      )\n        .then((\n          pagePromises // todo: I'd love to replace this with\n        ) =>\n          // .then(Promise.all)\n          // à la http://www.html5rocks.com/en/tutorials/es6/promises/#toc-transforming-values\n          Promise.all(pagePromises)\n        )\n        .then(pages => {\n          pages.forEach(page => {\n            page.items.forEach(item => {\n              tracks.push(item && item.track);\n            });\n          });\n          resolve(tracks);\n        })\n        .catch(reject);\n    });\n  }\n\n  static async removeDuplicates(api, playlistModel: PlaylistModel) {\n    return new Promise((resolve, reject) => {\n      if (playlistModel.playlist.id === 'starred') {\n        reject(\n          'It is not possible to delete duplicates from your Starred playlist using this tool since this is not supported in the Spotify Web API. You will need to remove these manually.'\n        );\n      }\n      if (playlistModel.playlist.collaborative) {\n        reject(\n          'It is not possible to delete duplicates from a collaborative playlist using this tool since this is not supported in the Spotify Web API. You will need to remove these manually.'\n        );\n      } else {\n        const tracksToRemove = playlistModel.duplicates\n          .map(d => ({\n            uri: d.track.linked_from ? d.track.linked_from.uri : d.track.uri,\n            positions: [d.index],\n          }))\n          .reverse(); // reverse so we delete the last ones first\n        const promises = [];\n        do {\n          const chunk = tracksToRemove.splice(0, 100);\n          (function(playlistModel, chunk, api) {\n            promises.push(() =>\n              api.removeTracksFromPlaylist(\n                playlistModel.playlist.owner.id,\n                playlistModel.playlist.id,\n                chunk\n              )\n            );\n          })(playlistModel, chunk, api);\n        } while (tracksToRemove.length > 0);\n\n        promises\n          .reduce(\n            (promise, func) => promise.then(() => func()),\n            Promise.resolve(null)\n          )\n          .then(() => {\n            playlistModel.duplicates = [];\n            resolve();\n          })\n          .catch(e => {\n            reject(e);\n          });\n      }\n    });\n  }\n}\n\nexport class SavedTracksDeduplicator extends BaseDeduplicator {\n  static async getTracks(\n    api,\n    initialRequest\n  ): Promise<Array<SpotifyTrackType>> {\n    return new Promise((resolve, reject) => {\n      const tracks = [];\n      promisesForPages(api, initialRequest)\n        .then((\n          pagePromises // todo: I'd love to replace this with\n        ) =>\n          // .then(Promise.all)\n          // à la http://www.html5rocks.com/en/tutorials/es6/promises/#toc-transforming-values\n          Promise.all(pagePromises)\n        )\n        .then(pages => {\n          pages.forEach(page => {\n            page.items.forEach(item => {\n              tracks.push(item.track);\n            });\n          });\n          resolve(tracks);\n        })\n        .catch(e => {\n          console.error(\n            `There was an error fetching the tracks from playlist ${initialRequest.href}`,\n            e\n          );\n          reject(e);\n        });\n    });\n  }\n\n  static async removeDuplicates(\n    api,\n    model: {\n      duplicates: Array<{\n        index: number;\n        reason: string;\n        track: SpotifyTrackType;\n      }>;\n    }\n  ) {\n    return new Promise((resolve, reject) => {\n      const tracksToRemove: Array<string> = model.duplicates.map(d =>\n        d.track.linked_from ? d.track.linked_from.id : d.track.id\n      );\n      do {\n        (async () => {\n          const chunk = tracksToRemove.splice(0, 50);\n          await api.removeFromMySavedTracks(chunk);\n        })();\n      } while (tracksToRemove.length > 0);\n      model.duplicates = [];\n      resolve();\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAGA;;;;;;;AACA;;;;;AACA;AACA;;;;;;;;;;;;;;;AAGA;AACA;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAGA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AAIA;AAAA;AAIA;AACA;AALA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCA;AACA;AAGA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAAA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAhCA;AAiCA;AACA;AACA;AA5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AA+EA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AAAA;AAIA;AACA;AALA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4CA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;;;;A","sourceRoot":""}